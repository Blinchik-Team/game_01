local COLLISION_RESPONSE = hash("collision_response")
local TRIGGER_RESPONSE = hash("trigger_response")
local ENEMIES = hash("enemies")

local DAMAGE = 10               -- урон (можно подправить)
local ATTACK_INTERVAL = 0.5    -- время между атаками

local function update_animation(self)
	-- Определяем направление взгляда по горизонтали и сохраняем в self.facing_left
	if self.dir.x > 0 then
		self.facing_left = false
	elseif self.dir.x < 0 then
		self.facing_left = true
	end

	if self.dir.x ~= 0 then
		if self.facing_left and self.current_animation ~= "left" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			go.set(go.get_id(), "scale", vmath.vector3(-1, 1, 1))
			self.current_animation = "left"
		elseif not self.facing_left and self.current_animation ~= "right" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			go.set(go.get_id(), "scale", vmath.vector3(1, 1, 1))
			self.current_animation = "right"
		end
	else
		if self.dir.y > 0 and self.current_animation ~= "up" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			local scale_x = self.facing_left and -1 or 1
			go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
			self.current_animation = "up"
		elseif self.dir.y < 0 and self.current_animation ~= "down" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			local scale_x = self.facing_left and -1 or 1
			go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
			self.current_animation = "down"
		end
	end
	if not self.moving and self.current_animation ~= "idle" then
		spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
		self.current_animation = "idle"
	end
	-- print(self.current_animation, self.facing_left)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.moving = false
	self.input = vmath.vector3()
	self.dir = vmath.vector3(0, 1, 0)
	self.speed = 300
	self.current_animation = "idle"
	spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
	
	-- Механика врагов в зоне и атаки
	self.enemies_in_range = {}  -- словарь для быстрого поиска
	self.enemies_list = {}      -- упорядоченный список для перебора по очереди
	self.current_enemy_index = 1

	self.fire_cooldown = 0
	self.fire_interval = ATTACK_INTERVAL
	self.attack_anims = {"front", "back"}  -- список анимаций удара
	self.last_attack_index = 0             
	
	self.url_spinemodel = msg.url("#spinemodel")
	
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function distance_to(my_pos, other_id)
	if go.exists(other_id) then
		return vmath.length(my_pos - go.get_position(other_id))
	end
	return math.huge
end

local function find_closest_enemy(self)
	local closest_id = nil
	local min_distance = 300 -- можно параметризовать fire_range
	local my_pos = go.get_position()
	for enemy_id, _ in pairs(self.enemies_in_range) do
		if go.exists(enemy_id) then
			local dist = distance_to(my_pos, enemy_id)
			if dist <= min_distance then
				min_distance = dist
				closest_id = enemy_id
			end
		else
			-- Удаляем несуществующих врагов
			self.enemies_in_range[enemy_id] = nil
		end
	end
	return closest_id
end

local function add_enemy(self, enemy_id)
	if not self.enemies_in_range[enemy_id] then
		self.enemies_in_range[enemy_id] = true
		table.insert(self.enemies_list, enemy_id)
	end
end

local function remove_enemy(self, enemy_id)
	if self.enemies_in_range[enemy_id] then
		self.enemies_in_range[enemy_id] = nil
		for i, id in ipairs(self.enemies_list) do
			if id == enemy_id then
				table.remove(self.enemies_list, i)
				if self.current_enemy_index > #self.enemies_list then
					self.current_enemy_index = 1
				end
				break
			end
		end
	end
end

local function attack_enemy(self, enemy_id)
	if enemy_id and go.exists(enemy_id) then
		-- Можно добавить анимацию удара здесь, если нужно
		--spine.play_anim("#spinemodel", "attack_no_wearpon_back", go.PLAYBACK_LOOP_FORWARD)
		-- Отправляем сообщение о нанесении урона
		msg.post(enemy_id, "apply_damage", { amount = DAMAGE })
		print("Attacked enemy:", enemy_id)
	end
end

function update(self, dt)
	self.fire_cooldown = math.max(0, self.fire_cooldown - dt)

	if self.moving then
		local pos = go.get_position()
		pos = pos + self.dir * self.speed * dt
		go.set_position(pos)
		update_animation(self)
	else
		if self.current_animation ~= "idle" then
			spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
			self.current_animation = "idle"
		end
	end

	self.input.x = 0
	self.input.y = 0
	self.moving = false

	-- Атака врагов по очереди из enemies_list
	if self.fire_cooldown <= 0 and #self.enemies_list > 0 then
		local target_enemy = self.enemies_list[self.current_enemy_index]

		if target_enemy and go.exists(target_enemy) then
			if self.last_attack_index == 0 then
				spine.play_anim("#spinemodel", "attack_no_wearpon_front", go.PLAYBACK_LOOP_FORWARD)
				go.set(self.url_spinemodel, "playback_rate", 2)
				self.last_attack_index = 1
			elseif self.last_attack_index == 1 then
				spine.play_anim("#spinemodel", "attack_no_wearpon_back", go.PLAYBACK_LOOP_FORWARD)
				go.set(self.url_spinemodel, "playback_rate", 2)
				self.last_attack_index = 0
			end
			
			attack_enemy(self, target_enemy)
			self.current_enemy_index = self.current_enemy_index + 1
			if self.current_enemy_index > #self.enemies_list then
				self.current_enemy_index = 1
			end
			self.fire_cooldown = self.fire_interval
		else
			-- Если враг удалён, убираем его из списка
			remove_enemy(self, target_enemy)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("up") then
		self.input.y = 1
	elseif action_id == hash("down") then
		self.input.y = -1
	elseif action_id == hash("left") then
		self.input.x = -1
	elseif action_id == hash("right") then
		self.input.x = 1
	end
	if vmath.length(self.input) > 0 then
		self.moving = true
		self.dir = vmath.normalize(self.input)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == COLLISION_RESPONSE and message.own_group == hash("player") and message.group == ENEMIES then
		print("Player collided with enemy: ID=" .. tostring(sender))
	elseif message_id == TRIGGER_RESPONSE and message.group == ENEMIES then
		if message.enter then
			add_enemy(self, message.other_id)
			print("Enemy entered range: ID=" .. tostring(message.other_id))
		else
			remove_enemy(self, message.other_id)
			print("Enemy left range: ID=" .. tostring(message.other_id))
		end
	end
	if message_id == hash("contact_point_response") then
		go.set_position(go.get_position() + message.normal * message.distance)
	end
end
