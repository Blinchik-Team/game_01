	local COLLISION_RESPONSE = hash("collision_response")   -- Константа для идентификации сообщений о столкновениях
	local TRIGGER_RESPONSE = hash("trigger_response")       -- Константа для идентификации сообщений о триггерах
	local ENEMY = hash("enemy")                         -- Константа для хэша группы врагов
	local DAMAGE = 10                                       -- Количество урона, наносимого врагам
	local ATTACK_INTERVAL = 0.5                             -- Время между атаками в секундах
	local ATTACK_RANGE = 50                                 -- Радиус, в котором происходит атака

	local weapon_stats = {
		sword_1 = { damage = 15 },
		axe_1 = { damage = 20 },
		-- Добавьте другие оружия по необходимости
	}
	
	local active_skins = {
		base = "",
		-- default mix skins
		hair = "body/hair_1",
		beard = "body/beard_1",
		body = "body/body_1",
		pans = "clothes/pans_1",
		boots = "clothes/boots_1",

		armor = "clothes/armor_1",
		helmet = "clothes/helmed/helmed_1",
		cloak = "clothes/cloak_1",

		weapon_back = "weapons/axe_1_back",
		weapon_front = "weapons/axe_1_front",
	}

	local function apply_skins(self)
		spine.clear_skin(self.spinemodel, active_skins.base)
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.head)
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.beard)
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.body)
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.hair)
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.pans)
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.boots)
		if active_skins.armor then
			spine.add_skin(self.spinemodel, active_skins.base, active_skins.armor)
		end
		if active_skins.weapon_back then
			spine.add_skin(self.spinemodel, active_skins.base, active_skins.weapon_back)
		end
		if active_skins.weapon_front then
			spine.add_skin(self.spinemodel, active_skins.base, active_skins.weapon_front)
		end
		if active_skins.helmet then
			spine.add_skin(self.spinemodel, active_skins.base, active_skins.helmet)
		end
		if active_skins.cloak then
			spine.add_skin(self.spinemodel, active_skins.base, active_skins.cloak)
		end
		spine.set_skin(self.spinemodel, active_skins.base)
	end
	
	local weapon_attack_animations = {
		no_weapon = { 
			melee = { front = "attack_no_weapon_front", back = "attack_no_weapon_back" },
			slash = { front = "attack_no_weapon_front", back = "attack_no_weapon_back" },
		},
		sword_1 = {
			melee = { front = "attack_sword_mili_front", back = "attack_sword_mili_back" },
			slash = { front = "attack_sword_slash_front", back = "attack_sword_slash_back" }
		},
		axe_1 = {
			melee = { front = "attack_axe_mili_front", back = "attack_axe_mili_back" },
			slash = { front = "attack_axe_slash_front", back = "attack_axe_slash_back" }
		},
		-- И так далее для других оружий
	}

	
-- 	-- Автоматическая стрельба
-- 	if self.fire_cooldown <= 0 then
-- 		local my_pos = go.get_position()
-- 		local fire_dir = nil
-- 		local rot = nil
-- 
-- 		local closest_enemy = find_closest_enemy(self)
-- 		if closest_enemy and go.exists(closest_enemy) then
-- 			local enemy_pos = go.get_position(closest_enemy)
-- 			fire_dir = vmath.normalize(enemy_pos - my_pos)
-- 			if vmath.length(fire_dir) < 0.1 then
-- 				print("Warning: fire_dir near zero, skipping shot")
-- 				return
-- 			end
-- 			-- print("Targeting enemy: ID=" .. tostring(closest_enemy) .. ", Pos=" .. tostring(enemy_pos) .. ", Dir=" .. tostring(fire_dir))
-- 		else
-- 			-- Не стреляем, если нет врагов
-- 			return
-- 		end
-- 
-- 		local angle = math.atan2(fire_dir.y, fire_dir.x)
-- 		rot = vmath.quat_rotation_z(angle)
-- 		local offset = fire_dir * 50
-- 		local bullet_pos = my_pos + offset
-- 		local bullet_id = factory.create("/arena#bulletsfactory", bullet_pos, rot, { dir = fire_dir })
-- 		self.fire_cooldown = self.fire_interval
-- 		-- print("Bullet spawned: ID=" .. tostring(bullet_id) .. ", Pos=" .. tostring(bullet_pos) .. ", Dir=" .. tostring(fire_dir))
-- 	end


-- Функция рекурсивного сравнения и вывода изменений
local function print_stat_changes(old_stats, new_stats, indent)
	indent = indent or 0
	local prefix = string.rep("  ", indent)
	for k, new_v in pairs(new_stats) do
		local old_v = old_stats[k]
		if type(new_v) == "table" and type(old_v) == "table" then
			print(prefix .. tostring(k) .. ":")
			print_stat_changes(old_v, new_v, indent + 1)
		else
			if new_v ~= old_v then
				print(string.format("%s%s изменился: %s -> %s", prefix, tostring(k), tostring(old_v), tostring(new_v)))
			end
		end
	end
end


-- Пример использования:

-- base_stats — старые статы персонажа
-- new_stats — новые статы (например, после применения бонусов)

-- print_stat_changes(base_stats, new_stats)


local function print_stats_table(t, indent)
	indent = indent or 0
	local prefix = string.rep("  ", indent)
	for k, v in pairs(t) do
		if type(v) == "table" then
			print(prefix .. tostring(k) .. ":")
			print_stats_table(v, indent + 1)
		else
			print(prefix .. tostring(k) .. ": " .. tostring(v))
		end
	end
end


function apply_god_bonuses(stats, god)
	-- Создаём копию таблицы stats, чтобы не менять исходные данные
	local new_stats = {}
	for k, v in pairs(stats) do
		if type(v) == "table" then
			new_stats[k] = {}
			for k2, v2 in pairs(v) do
				new_stats[k][k2] = v2
			end
		else
			new_stats[k] = v
		end
	end

	if god == "Один" then
		new_stats.range = (new_stats.range or 0) * 1.15  -- +15% Дальность
		if new_stats.critical then
			new_stats.critical.critMultiplier = (new_stats.critical.critMultiplier or 1) * 1.5 -- +50% крит-урон
		end
		new_stats.hpMax = (new_stats.hpMax or 0) * 0.5  -- -50% HP
	elseif god == "Тор" then
		new_stats.damageMultipliers.melee = (new_stats.damageMultipliers.melee or 1) * 1.2 -- +20% Мили
		new_stats.attackSpeed = (new_stats.attackSpeed or 0) * 1.15 -- +15% Скорость атаки
		new_stats.speed = (new_stats.speed or 0) * 0.8 -- -20% Скорость
	elseif god == "Фрея" then
		new_stats.regeneration = (new_stats.regeneration or 0) + 1 -- +1 Реген/сек
		new_stats.damageMultipliers.melee = (new_stats.damageMultipliers.melee or 1) * 0.8 -- -20% Мили
	elseif god == "Локи" then
		new_stats.speed = (new_stats.speed or 0) * 1.2 -- +20% Скорость
		new_stats.evasion = (new_stats.evasion or 0) * 1.15 -- +15% Уклон
		-- Эффект на лечение — сложнее, логика должна быть в боевой системе
	elseif god == "Тюр" then
		new_stats.armor = (new_stats.armor or 0) * 1.5 -- +50% Броня
		new_stats.hpMax = (new_stats.hpMax or 0) * 1.5 -- +50% HP
		new_stats.only_one_weapon = true -- флаг для ограничения оружия
	elseif god == "Фрейр" then
		new_stats.heal_effectiveness = (new_stats.heal_effectiveness or 1) * 1.5 -- +50% к лечению/шансам
		local dmg_mult = new_stats.damageMultipliers
		if dmg_mult then
			for k,v in pairs(dmg_mult) do dmg_mult[k] = v * 0.8 end  -- -20% урон всех типов
		end
	elseif god == "Брунхильда" then
		new_stats.auto_resurrect = (new_stats.auto_resurrect or 0) + 1
		new_stats.shop_slots = (new_stats.shop_slots or 4) - 1 -- -1 слот
	elseif god == "Скади" then
		new_stats.slow_on_ranged_hit = true -- специфичный эффект, реализуется в боевой логике
		new_stats.evasion = (new_stats.evasion or 0) * 0.8 -- -20% Уклон
	elseif god == "Мимир" then
		new_stats.additional_teacher_choice = (new_stats.additional_teacher_choice or 0) + 1
		new_stats.shop_wave_cooldown = (new_stats.shop_wave_cooldown or 1) * 2 -- магазин раз в 2 волны
	end

	return new_stats
end

	-- Функция, обновляющая анимацию персонажа в зависимости от направления движения
	local function update_animation(self)
		-- Выбирает направление взгляда по оси X (лево или право)
		if self.dir.x > 0 then
			self.facing_left = false
		elseif self.dir.x < 0 then
			self.facing_left = true
		end

		-- Если движение есть по оси X, проигрывает анимацию бега и устанавливает отражение спрайта
		if self.dir.x ~= 0 then
			if self.facing_left and self.current_animation ~= "left" then
				spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)  -- Запускает анимацию бега
				go.set(go.get_id(), "scale", vmath.vector3(-1, 1, 1))            -- Отражает спрайт по X влево
				self.current_animation = "left"                                   -- Запоминает текущую анимацию
			elseif not self.facing_left and self.current_animation ~= "right" then
				spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)  -- Бег вправо
				go.set(go.get_id(), "scale", vmath.vector3(1, 1, 1))             -- Обычное отображение спрайта
				self.current_animation = "right"
			end
		else
			-- Если движение по X отсутствует, проверяет ось Y и проигрывает соответствующую анимацию
			if self.dir.y > 0 and self.current_animation ~= "up" then
				spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)  -- Бег вверх
				local scale_x = self.facing_left and -1 or 1                     -- Отражение в зависимости от направления лица
				go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
				self.current_animation = "up"
			elseif self.dir.y < 0 and self.current_animation ~= "down" then
				spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)  -- Бег вниз
				local scale_x = self.facing_left and -1 or 1
				go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
				self.current_animation = "down"
			end
		end

		-- Если персонаж стоит на месте, проигрывает анимацию idle (покой)
		if not self.moving and self.current_animation ~= "idle" then
			spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD) -- Анимация покоя
			self.current_animation = "idle"
		end
	end
	
	local function spine_callback(self, node, event, data)
		print("Spine event:", event, data.name)
	end
	
	-- Функция инициализации
	function init(self)
		math.randomseed(os.time())
		math.random() -- "прогреть" генератор
		
		-- Парсим статы игрока
		local file_path = "/assets/data/player_stats.json"
		local content = sys.load_resource(file_path)
		if content then
			local success, data = pcall(json.decode, content)
			if success and data and data.stats then
				-- Сохраняем все статы в поле self.stats
				self.stats = data.stats

				-- Теперь можно обращаться к ним, например:
				print("HP max:", self.stats.hpMax)
				print("Damage multiplier for melee:", self.stats.damageMultipliers.melee)

				-- Пройтись по всем полям и вывести
				local function pprint_table(t, indent)
					indent = indent or 0
					local prefix = string.rep("  ", indent)
					for k, v in pairs(t) do
						if type(v) == "table" then
							print(prefix .. tostring(k) .. ":")
							pprint_table(v, indent + 1)
						else
							print(prefix .. tostring(k) .. ": " .. tostring(v))
						end
					end
				end

				pprint_table(self.stats)
			else
				print("Не удалось расшифровать JSON или отсутствует поле stats")
			end
		else
			print("Ошибка загрузки файла: " .. file_path)
		end
		
-- 		-- Загружает базовые статы из JSON
-- 		local base_stats = self.stats
-- 
-- 		-- Выбрали бога, например "Тор"
-- 		local chosen_god = "Тор"
-- 
-- 		-- Применяем бонусы
-- 		self.stats = apply_god_bonuses(base_stats, chosen_god)
-- 		print("Статы под бафом бога: ", chosen_god)
-- 		-- Использование:
-- 		print_stats_table(self.stats)
-- 
-- 		local base_stats = self.stats -- исходные статы
-- 		local new_stats = apply_god_bonuses(base_stats, chosen_god)
-- 
-- 		print("Изменения статов после выбора бога " .. chosen_god .. ":")
-- 		print_stat_changes(base_stats, new_stats)
-- 
-- 		self.stats = new_stats

		msg.post("/arena#game", "player_stats", { player_stats = self.stats})
		msg.post(".", "acquire_input_focus")  -- Захватываем фокус ввода для объекта

		self.moving = false                   -- Флаг движения персонажа
		self.input = vmath.vector3()          -- Вектор ввода (направление движения)
		self.dir = vmath.vector3(0, 1, 0)     -- Текущая направленность персонажа (по умолчанию вверх)
		self.speed = 300                      -- Скорость персонажа
		self.current_animation = "idle"       -- Текущая анимация персонажа
		spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD) -- Стартуем с анимации покоя

		self.enemies_in_range = {}            -- Таблица для быстрого поиска врагов в зоне
		self.enemies_list = {}                -- Упорядоченный список врагов для перебора
		self.current_enemy_index = 1          -- Индекс врага, по которому сейчас производится атака
		self.fire_cooldown = 0                -- Таймер перезарядки атаки
		self.fire_interval = ATTACK_INTERVAL  -- Интервал между атаками
		self.attack_anims = {"front", "back"}  -- Список анимаций атаки
		self.last_attack_index = 0             -- Индекс последней проигранной анимации атаки
		
		self.url_spinemodel = msg.url("#spinemodel")  -- URL spine-модели для управления анимациями

		self.armor = false
		self.hand_r = false
		self.hand_l = false
		self.helmed = false
		self.cloak = false

		self.spinemodel = msg.url(nil, go.get_id(), "spinemodel")
		-- Применяем скины по умолчанию
		apply_skins(self)
	end

	-- Добавляет врага в зоны обнаружения и в список для атаки
	local function add_enemy(self, enemy_id)
		if not self.enemies_in_range[enemy_id] then
			self.enemies_in_range[enemy_id] = true
			table.insert(self.enemies_list, enemy_id)
		end
	end

	-- Удаляет врага из зон обнаружения и списка атакованных врагов
	local function remove_enemy(self, enemy_id)
		if self.enemies_in_range[enemy_id] then
			self.enemies_in_range[enemy_id] = nil
			for i, id in ipairs(self.enemies_list) do
				if id == enemy_id then
					table.remove(self.enemies_list, i)
					if self.current_enemy_index > #self.enemies_list then
						self.current_enemy_index = 1
					end
					break
				end
			end
		end
	end

	-- Отправляет сообщение врагу о нанесении урона
	local function attack_enemy(self, enemy_id)
		if enemy_id and go.exists(enemy_id) then
			msg.post(enemy_id, "apply_damage", { amount = DAMAGE })
			print("Attacked enemy:", enemy_id)
		end
	end

	-- Основная функция обновления, вызываемая каждый кадр
	function update(self, dt)

		-- Обработка таймера перезарядки атаки
		self.fire_cooldown = math.max(0, self.fire_cooldown - dt)

		-- Если персонаж двигается, обновляем позицию и анимацию
		if self.moving then
			local pos = go.get_position()
			pos = pos + self.dir * self.speed * dt
			go.set_position(pos)
			update_animation(self)
		else
			-- Если персонаж стоит, обеспечиваем проигрывание анимации покоя
			if self.current_animation ~= "idle" then
				spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
				self.current_animation = "idle"
			end
		end

		-- Обнуляем ввод и флаг движения перед следующим кадром
		self.input.x = 0
		self.input.y = 0
		self.moving = false

		if self.fire_cooldown <= 0 and #self.enemies_list > 0 then
			local player_pos = go.get_position()

			local attacked = false
			local attempts = 0
			local max_attempts = #self.enemies_list

			while not attacked and attempts < max_attempts do
				local enemy_id = self.enemies_list[self.current_enemy_index]
				if go.exists(enemy_id) then
					local enemy_pos = go.get_position(enemy_id)
					local dir_to_enemy = enemy_pos - player_pos
					
					if (self.facing_left and dir_to_enemy.x < 0) or (not self.facing_left and dir_to_enemy.x > 0) then
						-- Проигрываем анимацию атаки
						if self.last_attack_index == 0 then
							spine.play_anim("#spinemodel", "attack_mili_slash_front", go.PLAYBACK_ONCE_FORWARD, { track = 2 }, anim_done)
							go.set(self.url_spinemodel, "playback_rate", 2)
							self.last_attack_index = 1
						else
							spine.play_anim("#spinemodel", "attack_mili_slash_back", go.PLAYBACK_ONCE_FORWARD, { track = 2 }, anim_done)
							go.set(self.url_spinemodel, "playback_rate", 2)
							self.last_attack_index = 0
						end
						-- Наносим урон выбранному врагу
						msg.post(enemy_id, "damage", { amount = 5000 })
						print("Attacked enemy:", enemy_id)
						attacked = true
					end
				else
					remove_enemy(self, self.enemies_list[self.current_enemy_index])
				end

				-- Переходим к следующему врагу в списке
				self.current_enemy_index = self.current_enemy_index + 1
				if self.current_enemy_index > #self.enemies_list then
					self.current_enemy_index = 1
				end

				attempts = attempts + 1
			end

			if attacked then
				self.fire_cooldown = self.fire_interval
			end
		end

end
	-- Обработка ввода пользователем (клавиатура, геймпад)
	function on_input(self, action_id, action)
		if action_id == hash("up") then
			self.input.y = 1
		elseif action_id == hash("down") then
			self.input.y = -1
		elseif action_id == hash("left") then
			self.input.x = -1
		elseif action_id == hash("right") then
			self.input.x = 1
		end

		-- Если есть введённое направление — активируем движение и нормализуем направление
		if vmath.length(self.input) > 0 then
			self.moving = true
			self.dir = vmath.normalize(self.input)
		end
		if action.released then
			if action_id == hash("item1") then
				active_skins.armor = "armor_1"
			elseif action_id == hash("item2") then
				active_skins.weapon_back = "axe_1_back"
			elseif action_id == hash("item3") then
				active_skins.weapon_front = "axe_1_front"
			elseif action_id == hash("item4") then
				active_skins.helmet = "helmed_1"
			elseif action_id == hash("item5") then
				active_skins.cloak = "cloak_1"
			end
			apply_skins(self)
		end
			
	end

	-- Обработка сообщений столкновений и триггеров
	function on_message(self, message_id, message, sender)
		-- Сообщение о столкновении с врагом
		if message_id == COLLISION_RESPONSE and message.own_group == hash("player") and message.group == ENEMY then
			print("Player collided with enemy: ID=" .. tostring(sender))
			-- Сообщение о входе или выходе врага из триггерной зоны
		elseif message_id == TRIGGER_RESPONSE and message.group == ENEMY then
			if message.enter then
				add_enemy(self, message.other_id)
				print("Enemy entered range: ID=" .. tostring(message.other_id))
			else
				remove_enemy(self, message.other_id)
				print("Enemy left range: ID=" .. tostring(message.other_id))
				
			end
		end

		-- Коррекция позиции при столкновении
		if message_id == hash("contact_point_response") then
			go.set_position(go.get_position() + message.normal * message.distance)
		end

		if message_id == hash("change_skin") and message.skin then
			local node = gui.get_node("spine_node")
			-- Добавляем два скина одновременно
			gui.add_spine_skin(node, "monster_head", "monster_body")
			spine.set_skin(self.url_spinemodel, message.skin)
		end
		if message_id == hash("request_player_stats") then
			msg.post(sender, "get_player_stats", { player_stats = self.stats })
		end
	end