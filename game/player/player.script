local COLLISION_RESPONSE = hash("collision_response")
local TRIGGER_RESPONSE = hash("trigger_response")
local ENEMY = hash("enemy")
local DAMAGE = 10
local ATTACK_INTERVAL = 0.5
local ATTACK_RANGE = 50
local weapon_stats = {
	sword_1 = { damage = 15 },
	axe_1 = { damage = 20 },
}
local active_skins = {
	base = "",
	hair = "body/hair_1",
	beard = "body/beard_1",
	body = "body/body_1",
	pans = "clothes/pans_1",
	boots = "clothes/boots_1",
	armor = "clothes/armor_1",
	helmet = "clothes/helmed/helmed_1",
	cloak = "clothes/cloak_1",
	weapon_back = "weapons/axe_1_back",
	weapon_front = "weapons/axe_1_front",
}
local function apply_skins(self)
	spine.clear_skin(self.spinemodel, active_skins.base)
	spine.add_skin(self.spinemodel, active_skins.base, active_skins.head)
	spine.add_skin(self.spinemodel, active_skins.base, active_skins.beard)
	spine.add_skin(self.spinemodel, active_skins.base, active_skins.body)
	spine.add_skin(self.spinemodel, active_skins.base, active_skins.hair)
	spine.add_skin(self.spinemodel, active_skins.base, active_skins.pans)
	spine.add_skin(self.spinemodel, active_skins.base, active_skins.boots)
	if active_skins.armor then
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.armor)
	end
	if active_skins.weapon_back then
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.weapon_back)
	end
	if active_skins.weapon_front then
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.weapon_front)
	end
	if active_skins.helmet then
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.helmet)
	end
	if active_skins.cloak then
		spine.add_skin(self.spinemodel, active_skins.base, active_skins.cloak)
	end
	spine.set_skin(self.spinemodel, active_skins.base)
end

local weapon_attack_animations = {
	no_weapon = { 
		melee = { front = "attack_no_weapon_front", back = "attack_no_weapon_back" },
		slash = { front = "attack_no_weapon_front", back = "attack_no_weapon_back" },
	},
	sword_1 = {
		melee = { front = "attack_sword_mili_front", back = "attack_sword_mili_back" },
		slash = { front = "attack_sword_slash_front", back = "attack_sword_slash_back" }
	},
	axe_1 = {
		melee = { front = "attack_axe_mili_front", back = "attack_axe_mili_back" },
		slash = { front = "attack_axe_slash_front", back = "attack_axe_slash_back" }
	},
}

local function update_animation(self)
	if self.moving then
		spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD, { track = 1 } )
		local scale_x = self.facing_left and -1 or 1
		go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
		self.current_animation = self.facing_left and "left" or "right"
	else
		if self.current_animation ~= "idle" then
			spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD, { track = 1 } )
			self.current_animation = "idle"
		end
	end
end

-- local function update_animation(self)
-- 	if self.moving then
-- 		if self.current_animation ~= "run" then
-- 			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
-- 			self.current_animation = "run"
-- 			local scale_x = self.facing_left and -1 or 1
-- 			go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
-- 		end
-- 	else
-- 		if self.current_animation ~= "idle" then
-- 			spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
-- 			self.current_animation = "idle"
-- 			local scale_x = self.facing_left and -1 or 1
-- 			go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
-- 		end
-- 	end
-- end

local function spine_callback(self, node, event, data)
	print("Spine event:", event, data.name)
end

function init(self)
	math.randomseed(os.time())
	math.random()

	local file_path = "/assets/data/player_stats.json"
	local content = sys.load_resource(file_path)
	if content then
		local success, data = pcall(json.decode, content)
		if success and data and data.stats then
			self.stats = data.stats
			print("HP max:", self.stats.hpMax)
			print("Damage multiplier for melee:", self.stats.damageMultipliers.melee)
			local function pprint_table(t, indent)
				indent = indent or 0
				local prefix = string.rep("  ", indent)
				for k, v in pairs(t) do
					if type(v) == "table" then
						print(prefix .. tostring(k) .. ":")
						pprint_table(v, indent + 1)
					else
						print(prefix .. tostring(k) .. ": " .. tostring(v))
					end
				end
			end
			pprint_table(self.stats)
		else
			print("Не удалось расшифровать JSON или отсутствует поле stats")
		end
	else
		print("Ошибка загрузки файла: " .. file_path)
	end

	msg.post("/arena#game", "player_stats", { player_stats = self.stats })
	msg.post(".", "acquire_input_focus")
	self.moving = false
	self.input = vmath.vector3()
	self.dir = vmath.vector3(0, 1, 0)
	self.speed = 300
	self.current_animation = "idle"
	spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
	self.enemies_in_range = {}
	self.enemies_list = {}
	self.current_enemy_index = 1
	self.fire_cooldown = 0
	self.fire_interval = ATTACK_INTERVAL
	self.attack_anims = {"front", "back"}
	self.last_attack_index = 0
	self.url_spinemodel = msg.url("#spinemodel")
	self.armor = false
	self.hand_r = false
	self.hand_l = false
	self.helmed = false
	self.cloak = false
	self.spinemodel = msg.url(nil, go.get_id(), "spinemodel")
	apply_skins(self)
end

local function add_enemy(self, enemy_id)
	if not self.enemies_in_range[enemy_id] then
		self.enemies_in_range[enemy_id] = true
		table.insert(self.enemies_list, enemy_id)
	end
end

local function remove_enemy(self, enemy_id)
	if self.enemies_in_range[enemy_id] then
		self.enemies_in_range[enemy_id] = nil
		for i, id in ipairs(self.enemies_list) do
			if id == enemy_id then
				table.remove(self.enemies_list, i)
				if self.current_enemy_index > #self.enemies_list then
					self.current_enemy_index = 1
				end
				break
			end
		end
	end
end

local function find_closest_enemy(self)
	local player_pos = go.get_position()
	local closest_enemy = nil
	local min_dist = math.huge
	for _, enemy_id in ipairs(self.enemies_list) do
		if go.exists(enemy_id) then
			local enemy_pos = go.get_position(enemy_id)
			local dist = vmath.length(enemy_pos - player_pos)
			if dist < min_dist then
				min_dist = dist
				closest_enemy = enemy_id
			end
		end
	end
	return closest_enemy, min_dist
end

function update(self, dt)
	
	self.fire_cooldown = math.max(0, self.fire_cooldown - dt)

	local player_pos = go.get_position()
	local closest_enemy, dist = find_closest_enemy(self)
	if closest_enemy then
		local enemy_pos = go.get_position(closest_enemy)
		-- Определяем направление взгляда в сторону врага по оси X (без изменения движения)
		if enemy_pos.x < player_pos.x then
			self.facing_left = true
		else
			self.facing_left = false
		end
	end

	if self.moving then
		local pos = go.get_position()
		pos = pos + self.dir * self.speed * dt
		go.set_position(pos)
	end

	update_animation(self)

	self.input.x = 0
	self.input.y = 0
	self.moving = false

	if self.fire_cooldown <= 0 and #self.enemies_list > 0 then
		local attacked = false
		local attempts = 0
		local max_attempts = #self.enemies_list
		while not attacked and attempts < max_attempts do
			local enemy_id = self.enemies_list[self.current_enemy_index]
			if go.exists(enemy_id) then
				-- Анимация атаки поочередно
				if self.last_attack_index == 0 then
					spine.play_anim("#spinemodel", "attack_mili_slash_front", go.PLAYBACK_ONCE_FORWARD, { track = 2 })
					go.set(self.url_spinemodel, "playback_rate", 2)
					self.last_attack_index = 1
				else
					spine.play_anim("#spinemodel", "attack_mili_slash_back", go.PLAYBACK_ONCE_FORWARD, { track = 2 })
					go.set(self.url_spinemodel, "playback_rate", 2)
					self.last_attack_index = 0
				end
				msg.post(enemy_id, "damage", { amount = 5000 })
				print("Attacked enemy:", enemy_id)
				attacked = true
			else
				remove_enemy(self, self.enemies_list[self.current_enemy_index])
			end
			self.current_enemy_index = self.current_enemy_index + 1
			if self.current_enemy_index > #self.enemies_list then
				self.current_enemy_index = 1
			end
			attempts = attempts + 1
		end
		if attacked then
			self.fire_cooldown = self.fire_interval
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("up") then
		self.input.y = 1
	elseif action_id == hash("down") then
		self.input.y = -1
	elseif action_id == hash("left") then
		self.input.x = -1
	elseif action_id == hash("right") then
		self.input.x = 1
	end
	if vmath.length(self.input) > 0 then
		self.moving = true
		self.dir = vmath.normalize(self.input)
	end
	if action.released then
		if action_id == hash("item1") then
			active_skins.armor = "armor_1"
		elseif action_id == hash("item2") then
			active_skins.weapon_back = "axe_1_back"
		elseif action_id == hash("item3") then
			active_skins.weapon_front = "axe_1_front"
		elseif action_id == hash("item4") then
			active_skins.helmet = "helmed_1"
		elseif action_id == hash("item5") then
			active_skins.cloak = "cloak_1"
		end
		apply_skins(self)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == COLLISION_RESPONSE and message.own_group == hash("player") and message.group == ENEMY then
		print("Player collided with enemy: ID=" .. tostring(sender))
	elseif message_id == TRIGGER_RESPONSE and message.group == ENEMY then
		if message.enter then
			add_enemy(self, message.other_id)
			print("Enemy entered range: ID=" .. tostring(message.other_id))
		else
			remove_enemy(self, message.other_id)
			print("Enemy left range: ID=" .. tostring(message.other_id))
		end
	end
	if message_id == hash("contact_point_response") then
		go.set_position(go.get_position() + message.normal * message.distance)
	end
	if message_id == hash("change_skin") and message.skin then
		local node = gui.get_node("spine_node")
		gui.add_spine_skin(node, "monster_head", "monster_body")
		spine.set_skin(self.url_spinemodel, message.skin)
	end
	if message_id == hash("request_player_stats") then
		msg.post(sender, "get_player_stats", { player_stats = self.stats })
	end
end
