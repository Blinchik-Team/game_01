local EnemyInfo = require "game.enemy.enemy_info"

local function die(self)
	spine.play_anim(self.url_spinemodel, "dead", go.PLAYBACK_ONCE_FORWARD, { track = 1 }, function ()
		go.delete()
	end)
end

function init(self)
	local max_offset = 50  -- больше смещение, чтобы ворон держался на дистанции
	self.target_offset = vmath.vector3(
		(math.random() - 0.5) * 2 * max_offset,
		(math.random() - 0.5) * 2 * max_offset,
		0
	)
	self.move_time = 0
	self.phase = math.random() * 2 * math.pi  -- случайная начальная фаза
	self.url_spinemodel = "#spinemodel"
	self.player_id = self.player_id
	self.enemy_id = self.enemy_id or 7 -- ID ворона
	self.wave_number = self.wave_number or 1
	local data = EnemyInfo[self.enemy_id]

	self.max_hp = math.floor(data.health * (data.hpMultiplierPerWave ^ self.wave_number))
	self.current_hp = self.max_hp

	-- Скорость летающего врага с разбросом ±20%
	local speed_variation = 0.2
	local random_factor = 1 + (math.random() * 2 - 1) * speed_variation
	self.speed = data.speed * (data.speedMultiplierPerWave ^ self.wave_number) * random_factor

	self.melee_damage = 0  -- не наносит урон при касании
	self.ranged_damage = data.rangedDamage * (data.damageMultiplierPerWave ^ self.wave_number)

	self.attack_range = 100  -- дальность атаки, можно скорректировать по вашим параметрам
	self.attack_cooldown = 0
	self.attack_interval = 1.1  -- интервал между атаками

	self.gold_drop_amount = data.goldDropAmount
	self.beer_drop_chance_percent = data.beerDropChancePercent
	self.chest_drop_chance_percent = data.chestDropChancePercent

	self.name = data.name
	self.behavior = data.behavior
	self.special_action = data.specialAction

	spine.play_anim(self.url_spinemodel, "idle", go.PLAYBACK_LOOP_FORWARD, { track = 1 })
	self.is_moving = false
end

function update(self, dt)
	if not self.player_id then
		print("No player_id")
		return
	end

	self.move_time = self.move_time + dt
	local player_pos = go.get_position(self.player_id)
	local enemy_pos = go.get_position()

	-- Цель с учетом случайного смещения, держимся на расстоянии
	local adjusted_target = player_pos + self.target_offset

	local direction = adjusted_target - enemy_pos
	local distance_to_target = vmath.length(direction)

	if distance_to_target > 1 and self.speed and self.speed > 0 then
	direction = vmath.normalize(direction)

	-- Плавное колебание, чтобы летать с небольшим зигзагом
	local offset_x = math.sin(self.move_time * 3 + self.phase) * 2
	local offset_y = math.cos(self.move_time * 3 + self.phase) * 2

	-- Новая позиция с учётом направления и колебаний
	local new_pos = enemy_pos + direction * self.speed * dt + vmath.vector3(offset_x * dt, offset_y * dt, 0)
	go.set_position(new_pos)

	-- Отражение модели по оси X в зависимости от движения
	local scale = go.get_scale()
	if direction.x < 0 then
		scale.x = -math.abs(scale.x)
	else
		scale.x = math.abs(scale.x)
	end
	go.set(go.get_id(), "scale", scale)

	-- Запуск анимации полёта
	if not self.is_moving then
		spine.play_anim(self.url_spinemodel, "run", go.PLAYBACK_LOOP_FORWARD)
		self.is_moving = true
	end
	else
		-- Если стоим, переключаемся на анимацию ожидания
		if self.is_moving then
			spine.play_anim(self.url_spinemodel, "idle", go.PLAYBACK_LOOP_FORWARD)
			self.is_moving = false
		end
	end

	-- Атака с дальнего расстояния по интервалу
	self.attack_cooldown = math.max(0, (self.attack_cooldown or 0) - dt)
	if self.attack_cooldown <= 0 then
		local to_player = player_pos - enemy_pos
		local dist_to_player = vmath.length(to_player)
		if dist_to_player <= self.attack_range then
			-- Выпускаем дальнюю атаку (например, сообщение с уроном)
			msg.post(self.player_id, "apply_damage", { amount = self.ranged_damage })
			-- Можно добавить анимацию атаки
			spine.play_anim(self.url_spinemodel, "attack_ranged", go.PLAYBACK_ONCE_FORWARD)
			self.attack_cooldown = self.attack_interval
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("damage") then
		self.current_hp = self.current_hp - message.amount
		if self.current_hp <= 0 then
			die(self)
		end
	elseif message_id == hash("request_player_id") then
		msg.post(sender, "response_enemy_id", { enemy_url = go.get_id() })
	elseif message_id == hash("player_id") then
		self.player_id = message.player_id
	end
end
