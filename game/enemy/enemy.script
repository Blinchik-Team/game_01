local COLLISION_RESPONSE = hash("collision_response")
local CONTACT_POINT_RESPONSE = hash("contact_point_response")
local PLAYER = hash("player")
local PLAYER_BULLET = hash("player_bullet")
local WALL = hash("wall")

go.property("speed", 200)
go.property("attack_range", 50) -- радиус остановки и начала удара

local UP = vmath.vector3(0, 1, 0)
local RAD_180 = math.pi

function final(self)
	msg.post(".", "release_input_focus")
end

local function random_position_on_wall()
	local wall = math.random(1, 4)
	if wall == 1 then
		return vmath.vector3(0, math.random(0, 720), 0)
	elseif wall == 2 then
		return vmath.vector3(1156, math.random(0, 720), 0)
	elseif wall == 3 then
		return vmath.vector3(math.random(0, 1280), 0, 0)
	else
		return vmath.vector3(math.random(0, 1280), 720, 0)
	end
end

local function clamp(v, min, max)
	return math.max(min, math.min(max, v))
end

local function angle_to(id)
	local my_pos = go.get_position()
	local other_pos = go.get_position(id)
	return -math.atan2(other_pos.x - my_pos.x, other_pos.y - my_pos.y)
end

local function distance_to(id)
	local my_pos = go.get_position()
	local other_pos = go.get_position(id)
	return vmath.length(my_pos - other_pos)
end

local function update_animation(self)
	-- Определяем горизонтальное направление
	if self.dir.x > 0 then
		self.facing_left = false
	elseif self.dir.x < 0 then
		self.facing_left = true
	end
	if self.dir.x ~= 0 then
		if self.facing_left and self.current_animation ~= "left" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			go.set(go.get_id(), "scale", vmath.vector3(-1, 1, 1))
			self.current_animation = "left"
		elseif not self.facing_left and self.current_animation ~= "right" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			go.set(go.get_id(), "scale", vmath.vector3(1, 1, 1))
			self.current_animation = "right"
		end
	else
		if self.dir.y > 0 and self.current_animation ~= "up" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			local scale_x = self.facing_left and -1 or 1
			go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
			self.current_animation = "up"
		elseif self.dir.y < 0 and self.current_animation ~= "down" then
			spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
			local scale_x = self.facing_left and -1 or 1
			go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
			self.current_animation = "down"
		end
	end
	if not self.moving and self.current_animation ~= "idle" then
		spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
		self.current_animation = "idle"
	end
end

function init(self)
	-- Список ближайших врагов
	self.nearby = {}
	-- Инициализация без игрока
	self.player_found = false
	self.target_id = nil
	self.facing_left = false -- стартовая ориентация
	-- Инициализация списка анимаций атак и переменных
	self.attack_anims = {"attack_no_wearpon_front", "attack_no_wearpon_back"}
	self.last_attack_index = 0
	self.is_attacking = false -- Флаг текущей атаки
	self.current_animation = "idle"
	self.url_spinemodel = "#spinemodel"
	self.is_dead = false
	self.moving = false
	self.attack_timer = 0
	self.stop_movement = false
end

-- Функция, управляющая движением к цели
function move_towards_target(self, direction, dt)
	if self.stop_movement then
		self.moving = false
		return
	end
	local pos = go.get_position()
	if self.current_animation ~= "run" and not self.is_attacking then
		spine.play_anim("#spinemodel", "run", go.PLAYBACK_LOOP_FORWARD)
		self.current_animation = "run"
	end
	local move_dist = self.speed * dt
	go.set_position(pos + direction * move_dist)
	self.moving = true
	-- Сброс флага атаки и таймера
	self.is_attacking = false
	self.attack_timer = 0
end

function start_attack(self)
	self.is_attacking = true
	self.last_attack_index = (self.last_attack_index % #self.attack_anims) + 1
	local attack_anim = self.attack_anims[self.last_attack_index]
	print("Start attack animation:", attack_anim)
	spine.play_anim("#spinemodel", attack_anim, go.PLAYBACK_ONCE_FORWARD)
	self.current_animation = "attack"
	self.attack_timer = 0.7  -- примерная длительность анимации атаки в секундах
end

function finish_attack(self)
	self.is_attacking = false
	self.current_animation = "idle"
	spine.play_anim("#spinemodel", "idle", go.PLAYBACK_LOOP_FORWARD)
end


-- Функция выбора и воспроизведения текущей анимации
function update_animation_state(self, dt, dist)
	local prev_facing_left = self.facing_left
	local direction = self.dir
	if direction.x < 0 then
		self.facing_left = true
	elseif direction.x > 0 then
		self.facing_left = false
	end
	if self.facing_left ~= prev_facing_left then
		local scale_x = self.facing_left and -1 or 1
		go.set(go.get_id(), "scale", vmath.vector3(scale_x, 1, 1))
	end

	print("Distance to target:", dist, "Attack range:", self.attack_range)

	if dist > self.attack_range then
		move_towards_target(self, direction, dt)
	else
		self.moving = false
		if not self.is_attacking then
			start_attack(self)
		else
			self.attack_timer = self.attack_timer - dt
			if self.attack_timer <= 0 then
				finish_attack(self)
			end
		end
	end
end

function update(self, dt)
	if not self.is_dead and not self.stop_movement then
		local pos = go.get_position()
		local target_pos
		if self.target_id and go.exists(self.target_id) then
			target_pos = go.get_position(self.target_id)
		else
			target_pos = pos + vmath.vector3(0, 1, 0)
		end
		local direction = target_pos - pos
		direction.z = 0
		local dist = vmath.length(direction)
		if dist > 0 then
			direction = direction / dist
		end
		self.dir = direction
		update_animation_state(self, dt, dist)
	else
		self.moving = false
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("apply_damage") and not self.is_dead then
		self.is_dead = true
		self.stop_movement = true
		self.current_animation = "dead"
		spine.play_anim("#spinemodel", "dead", go.PLAYBACK_ONCE_FORWARD, {}, function(self_cb, message_id_cb, message_cb, sender_cb)
			if message_id_cb == hash("spine_animation_done") and message_cb.animation_id == hash("dead") then
				print("умер")
				msg.post("#co", "disable") -- отключение коллизий
				go.delete()
			end
		end)
	end
	if message_id == hash("trigger_response") then
		if message.enter then
			self.nearby[message.other_id] = true
		else
			self.nearby[message.other_id] = false
		end
	elseif message_id == hash("set_player") then
		self.target_id = message.player_id
		self.player_found = go.exists(self.target_id)
	end
	if message_id == COLLISION_RESPONSE then
		if message.group == PLAYER then
			local my_pos = go.get_world_position()
			local other_pos = go.get_world_position(message.other_id)
			local distance_to_target = vmath.length(my_pos - self.target_position)
			local distance_to_collision = vmath.length(my_pos - other_pos)
			if distance_to_collision < distance_to_target or not self.target_id then
				self.target_position = other_pos
				self.target_id = message.other_id
			end
		end
		if message.group == PLAYER_BULLET then
			--go.delete()
		end
	elseif message_id == CONTACT_POINT_RESPONSE then
		if message.group == WALL then
			go.set_position(go.get_position() + message.normal * message.distance)
			self.target_position = random_position_on_wall()
		end
	end
	if message_id == hash("contact_point_response") then
		go.set_position(go.get_position() + message.normal * message.distance)
	end	
end
